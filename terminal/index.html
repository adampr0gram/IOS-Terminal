<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>iOS Terminal (File Access)</title>

<link rel="manifest" href="/manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon" href="/icons/192.png">

<style>
@font-face {
    font-family: "Monaco";
    src: url("https://cdn.jsdelivr.net/gh/iamadamdev/fonts/Monaco.woff2") format("woff2");
}
html, body {
  height:100%; margin:0; background:#000; font-family: Monaco, monospace;
  overflow:hidden;
}
#terminal { width:100%; height:100%; }
</style>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css">
<script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>
</head>
<body>
<div id="terminal"></div>

<script>
// ---------------- Terminal Setup ----------------
const term = new Terminal({
  theme: { background:'#000', foreground:'#fff', cursor:'#fff' },
  fontFamily: 'Monaco, monospace',
  fontSize: 14,
  cursorBlink: true
});
term.open(document.getElementById('terminal'));

term.writeln('iOS Terminal — Direct File Access');
term.writeln('Type "help" for commands.');

let inputBuffer = '';
let openedFiles = {}; // filename -> FileHandle

function prompt(){ term.write("\n> "); }
prompt();

// ---------------- File Selection ----------------
async function pickFiles(multiple){
  const picker = document.createElement('input');
  picker.type = 'file';
  if(multiple) picker.multiple = true;

  return new Promise(res => {
    picker.onchange = () => res([...picker.files]);
    picker.click();
  });
}

async function openFiles(cmd){
  const multiple = !cmd.includes('-single');
  const files = await pickFiles(multiple);
  files.forEach(f => openedFiles[f.name] = f);
  return files.length + ' file(s) opened';
}

async function readFile(name){
  const f = openedFiles[name];
  if(!f) return 'File not opened';
  return await f.text();
}

async function writeFile(name, content){
  const f = openedFiles[name];
  if(!f) return 'File not opened';
  term.writeln('⚠️ iOS Safari does NOT support writing back to chosen files.');
  term.writeln('Use: export <filename> to download updated version.');
}

async function exportFile(name, content){
  const blob = new Blob([content], {type:'text/plain'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
}

// ---------------- Commands ----------------
async function handle(cmd){
  const p = cmd.split(' ');
  const c = p[0];
  const args = p.slice(1);

  switch(c){
    case 'help':
      term.writeln('Commands:');
      term.writeln(' open        — Pick multiple files');
      term.writeln(' open -single — Pick only 1 file');
      term.writeln(' read <file>');
      term.writeln(' write <file> <text>');
      term.writeln(' export <file> — download edited file');
      term.writeln(' nano <file>');
      term.writeln(' base64en <text>');
      term.writeln(' ping <host>');
      term.writeln(' web <url>');
      term.writeln(' credits');
      break;

    case 'open':
      term.writeln(await openFiles(cmd));
      break;

    case 'read':
      if(!args[0]) return term.writeln('Usage: read <file>');
      const r = await readFile(args[0]);
      term.writeln(r);
      break;

    case 'write':
      if(!args[0]) return term.writeln('Usage: write <file> <text>');
      await writeFile(args[0], args.slice(1).join(' '));
      break;

    case 'export':
      if(!args[0]) return term.writeln('Usage: export <file>');
      const dat = await readFile(args[0]);
      await exportFile(args[0], dat);
      term.writeln('Exported');
      break;

    case 'nano':
      if(!args[0]) return term.writeln('Usage: nano <file>');
      await nanoEditor(args[0]);
      break;

    case 'base64en':
      term.writeln(btoa(args.join(' ')));
      break;

    case 'ping':
      if(!args[0]) return term.writeln('Usage: ping <host>');
      term.writeln('Pinging...');
      try{ await fetch('https://' + args[0], {mode:'no-cors'}); term.writeln('Success'); }
      catch(e){ term.writeln('Timeout'); }
      break;

    case 'web':
      window.open(args[0], '_blank');
      break;

    case 'credits':
      term.writeln('Adam T. Nassar');
      break;

    default:
      term.writeln('Unknown command');
  }
}

// ---------------- nano editor ----------------
async function nanoEditor(file){
  let content = await readFile(file) || '';
  term.writeln('--- nano: ' + file + ' (Ctrl+X to save+exit) ---');
  term.write(content);

  let buf = content;
  const listener = term.onData(k => {
    if(k === '\u0018'){ // Ctrl+X
      listener.dispose();
      exportFile(file, buf);
      term.writeln('\nSaved (downloaded)');
      return;
    }
    if(k === '\u007F'){ buf = buf.slice(0,-1); term.write("\b \b"); return; }
    if(k === '\r'){ buf += '\n'; term.write('\n'); return; }
    buf += k; term.write(k);
  });
}

// ---------------- Input ----------------
term.onData(e => {
  if(e === '\r'){
    const cmd = inputBuffer.trim();
    inputBuffer = '';
    term.write('\n');
    handle(cmd);
    prompt();
  } else if(e === '\u007F'){
    if(inputBuffer.length>0){
      inputBuffer = inputBuffer.slice(0,-1);
      term.write("\b \b");
    }
  } else {
    inputBuffer += e;
    term.write(e);
  }
});
</script>
</body>
</html>
