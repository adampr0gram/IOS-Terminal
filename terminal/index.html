<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>iOS Terminal</title>

<link rel="manifest" href="/manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon" href="/icons/192.png">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css">
<script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>

<style>
@font-face {
    font-family: "Monaco";
    src: url("https://cdn.jsdelivr.net/gh/iamadamdev/fonts/Monaco.woff2") format("woff2");
    font-weight: normal;
    font-style: normal;
}

html, body {
    margin: 0;
    padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    width: 100%;
    height: 100%;
    background: #000;
    overflow: hidden;
}

#terminal { width: 100%; height: 100%; }

#permissionPopup {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.85);
    display: flex; align-items: center; justify-content: center;
    z-index: 9999;
}
#popupBox {
    background: #0d0d0d;
    padding: 22px;
    border-radius: 10px;
    border: 1px solid #333;
    width: 280px;
    text-align: center;
    color: #fff;
}
#chooseFolder {
    margin-top: 12px;
    width: 100%; padding: 10px;
    border-radius: 6px;
    border: none;
    background: #fff; color: #000;
    font-weight: 600; font-size: 16px;
}
</style>
</head>
<body>
<div id="terminal"></div>

<div id="permissionPopup">
    <div id="popupBox">
        <h3>Folder Access</h3>
        <p>Select a folder so commands can read/write files.</p>
        <button id="chooseFolder">Choose Folder</button>
    </div>
</div>

<script>
let dirHandle = null;
let buffer = "";
let cursorVisible = true;

const term = new Terminal({
    theme: { background: "#000", foreground: "#fff", cursor: "#ffffff" },
    fontFamily: "Monaco, monospace",
    fontSize: 14,
    cursorBlink: true,
    letterSpacing: 0,
    lineHeight: 1.2
});

term.open(document.getElementById("terminal"));

term.writeln("iOS Terminal Ready");
term.write("$ ");

// blinking cursor (enhanced)
setInterval(() => {
    cursorVisible = !cursorVisible;
    term.setOption("cursorStyle", cursorVisible ? "block" : "bar");
}, 500);

(async () => {
    const saved = localStorage.getItem("dir_saved");
    if (saved) {
        try { dirHandle = await window.showDirectoryPicker(); } catch {}
    }
    if (dirHandle) {
        document.getElementById("permissionPopup").style.display = "none";
        term.writeln("Folder permission restored.");
        term.write("$ ");
    } else {
        term.writeln("Waiting for folder permission...");
    }
})();

document.getElementById("chooseFolder").onclick = async () => {
    try {
        dirHandle = await window.showDirectoryPicker();
        await dirHandle.requestPermission({ mode: "readwrite" });
        localStorage.setItem("dir_saved", "yes");
        document.getElementById("permissionPopup").style.display = "none";
        term.writeln("\nFolder selected.");
        term.write("$ ");
    } catch {
        term.writeln("\nPermission denied.");
        term.write("$ ");
    }
};

term.onData(data => {
    if (data === "\r") {
        const cmd = buffer.trim(); buffer = "";
        term.write("\n");
        handleCommand(cmd);
        term.write("\n$ ");
    } else if (data === "\u007F") {
        if (buffer.length) {
            buffer = buffer.slice(0, -1);
            term.write("\b \b");
        }
    } else {
        buffer += data;
        term.write(data);
    }
});

async function realPing(host) {
    const url = host.startsWith("http") ? host : `https://${host}`;
    const start = performance.now();
    try {
        await fetch(url, { mode: "no-cors" });
        return `Reply from ${host}: time=${Math.round(performance.now() - start)}ms`;
    } catch {
        return `Request timed out to ${host}`;
    }
}

async function nanoEditor(filename) {
    term.writeln(`Opening nano: ${filename}`);
    term.writeln("--- Press CTRL+X to save & exit ---");

    let fileHandle;
    let existing = "";

    try {
        fileHandle = await dirHandle.getFileHandle(filename, { create: true });
        const file = await fileHandle.getFile();
        existing = await file.text();
    } catch {}

    let content = existing;
    term.writeln(content);

    const disposer = term.onData(async key => {
        if (key === "\u0018") { // CTRL+X
            disposer.dispose();
            const writable = await fileHandle.createWritable();
            await writable.write(content);
            await writable.close();
            term.writeln("\nSaved.");
            term.write("$ ");
        } else if (key === "\r") {
            content += "\n";
            term.write("\n");
        } else if (key === "\u007F") {
            content = content.slice(0, -1);
            term.write("\b \b");
        } else {
            content += key;
            term.write(key);
        }
    });
}

async function handleCommand(cmd) {
    if (!cmd) return;
    const [base, ...args] = cmd.split(" ");

    switch (base) {
        case "nano":
            if (!args[0]) return term.writeln("Usage: nano <file>");
            if (!dirHandle) return term.writeln("No folder selected.");
            nanoEditor(args[0]);
            break;

        case "help":
            term.writeln("Commands: help, ls, dir, cd, mkdir, rmdir, del, cls, spec, echo, ping, web, credits, nano, exit");
            break;

        case "cls": term.clear(); break;

        case "ls":
        case "dir":
            if (!dirHandle) return term.writeln("No folder selected.");
            for await (const entry of dirHandle.values()) term.writeln(entry.name);
            break;

        case "mkdir":
            if (!args[0]) return term.writeln("Usage: mkdir <name>");
            await dirHandle.getDirectoryHandle(args[0], { create: true });
            term.writeln("Folder created.");
            break;

        case "rmdir":
            if (!args[0]) return term.writeln("Usage: rmdir <name>");
            await dirHandle.removeEntry(args[0], { recursive: true });
            term.writeln("Folder removed.");
            break;

        case "del":
            if (!args[0]) return term.writeln("Usage: del <file>");
            await dirHandle.removeEntry(args[0]);
            term.writeln("File deleted.");
            break;

        case "echo": term.writeln(args.join(" ")); break;

        case "web":
            if (!args[0]) return term.writeln("Usage: web <url>");
            window.open(args[0], "_blank");
            term.writeln("Opened " + args[0]);
            break;

        case "ping":
            if (!args[0]) return term.writeln("Usage: ping <host>");
            term.writeln("Pinging " + args[0] + "...");
            term.writeln(await realPing(args[0]));
            break;

        case "spec":
            term.writeln("Device: iOS WebKit");
            term.writeln("UserAgent: " + navigator.userAgent);
            term.writeln("Cores: " + navigator.hardwareConcurrency);
            break;

        case "credits": term.writeln("Adam T. Nassar"); break;
        case "exit": term.writeln("Goodbye!"); break;

        default:
            term.writeln("Unknown command: " + base);
    }
}

if ("serviceWorker" in navigator) navigator.serviceWorker.register("/service-worker.js");
</script>

</body>
</html>
